---
title: '네트워크 이론'
date: '2025-12-12'
description: '네트워크 이론 정리'
---

# 네트워크 계층
<table border="1">
  <thead>
    <tr>
      <th>OSI 7계층</th>
      <th>Physical</th>
      <th>Data Link</th>
      <th>Network</th>
      <th>Transport</th>
      <th>Session</th>
      <th>Presentation</th>
      <th>Application</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>TCP/IP 4계층</th>
      <th colSpan="2">Network Access</th>
      <th>Internet</th>
      <th>Transport</th>
      <th colSpan="3">Application</th>
    </tr>
  </tbody>
</table>

개인적으로는 TCP/IP 4계층 구분을 좀 더 선호하지만 대부분 네트워크 이론 수업이나 교재가 osi 7계층 기반으로 작성돼 있기 때문에 이 페이지 또한 osi 7계층을 기반으로 정리를 하였습니다.  
다만, 물리 계층은 제외하였습니다. 

{/* 네트워크 계층화의 의의는 각 계층이 맡은 역할이 분리되어 있다는 점에 있습니다. 각 계층은 자신의 한 단계 아래 계층이 정상적으로 동작한다는 가정 하에 자신의 역할을 수행합니다.  
링크 계층에서는 물리적인 연견된 장비간의, LAN 범위에서의 네트워크 통신을 보장하며  
네트워크 계층에서는 이를 기반으로 라우팅을 통해 WAN 범위에서의 종단간 통신을 보장합니다  
트랜스포트 계층에서는 이를 기반으로 프로세스간의 통신을 보장합니다. 

네트워크 이론을 학습함으로써 네트워크에 문제가 생겼을 때의 해결을 할 수 있으며  
밑의 계층들에서 구현한 네트워크 로직을 모방하여 자신만의 네트워크 프로그램을 잘 작성할 수 있습니다. */}


# Network Access Layer

# Network Layer
네트워크 레이어는 종단 호스트간의 패킷 통신을 수행합니다. (전송 단위: 패킷)  
춣발지부터 목적지까지의 경로를 계산하는 라우팅, 포워딩이 주요 기능입니다.  

## 혼잡 제어
네트워크 트래픽이 과도하게 몰려 통신 성능이 악화되는 현상을 에방, 해결하기 위한 기능입니다.  
네트워크 경로 사이에 있는 개별 라우터가, 자신의 패킷 처리 능력을 넘어서는 패킷 입력이 들어오면 버퍼 용량이 넘쳐 버려지는 패킷이 많아지게 됩니다.
이를 해결하지 않고 계속해서 패킷을 보내 자신의 패킷을 처리하려고 하는 호스트, 라우터가 존재하면 네트워크 망 전체가 마비 되어 손해를 보게 됩니다.  

문제 해결 기법:
- TTL: 패킷이 네트워크에서 홉을 뛸 수 있는 횟수를 제한합니다. 홉을 뛸 때마다 라우터가 1씩 감소시키며 0이 될 시 해당 패킷을 내보내지 않고 버려버림으로써 네트워크에 존재하는 패킷의 전체적인 수를 감소시킵니다.  
- 혼잡 발생을 감지하면 혼잡이 발생한 지점(라우터)에 라우팅 되지 않도록 경로를 조정합니다.  
- 특정 호스트가 사용할 수 있는 트래픽 대역폭을 미리 설정해둡니다.  
- ECN(Explicit Congestion Notification) 패킷을 보내 혼잡을 알립니다.  

정리히자면, 기본적으로 라우터는 과도한 패킷이 들어올 시 패킷을 버립니다(Leaky Bucket). ECN 패킷을 보내 혼잡을 알려 라우팅 경로를 수정시킵니다. TTL을 사용해 네트워크 망에 패킷이 과도하게 돌아다니지 않도록 방지합니다. 

## 라우팅 
패킷의 전송 경로를 결정하는 기능으로, 네트워크 레이어의 핵심 기능입니다.

### 서비스 방식
- 1. 연결형 서비스  
    가상 회선을 설정해 고정된 경로를 통하여 송수신 하는 방식입니다. 신뢰성이 높지만 유동적이지 못합니다.
- 2. 비연결형 서비스  
    패킷이 라우터에서 독립적으로 처리되어 각 패킷이 제각각의 경로를 통해 목적지까지 전달됩니다. 패킷을 순서에 따라 재조립하는 과정이 필요합니다.

### 라우팅 방식
- 1. 정적 라우팅
    네트워크 관리자가 미리 라우터에 라우팅 테이블을 작성하여 고정된 라우팅 경로를 가지게 하는 방식입니다. 보안이 향상되고, 라우터 부하가 줄어들며 라우팅 오버헤드가 줄어든다는 단점이 있지만 유동적이지 못 하다는 것은 언제나 큰 단점입니다. 
- 2. 동적 라우팅
    라우터가 네트워크 상황을 고려해 라우팅 테이블을 수시로 변경하여 유동적으로 상황에 대처합니다. 라우팅 정보 수집 및 경로를 계산해야한다는 점이 생겨 라우터에 부하가 늘어납니다.

### 라우팅 기법
- 1. 소스 라우팅
    송신 호스트가 목적지까지의 경로를 직접 기록하여 송수신 하는 방식입니다. 이런 방식은 위험하기에 대부분의 라우터에서 차단해놓습니다. 보통 작은 규모의 통제적인 환경에서 활용됩니다.
- 2. 중앙 라우팅
    RCC(Routing Control Center)라는 특수 호스트를 사용해 네트워크의 전체 라우팅을 관리합니다. 패킷 전송시 출발 호스트가 RCC한테 경로를 받아온 뒤, 소스 라우팅을 사용해 목적지로 보냅니다.  
- 3. 분산 라우팅 
    각각의 라우터가 직접 거리 벡터 알고리즘을 통해 인접 노드에 대한 링크 정보를 기반으로 목적지까지의 최소 경로를 계산합니다.
- 4. 계층 라우팅 
    중앙 라우팅 + 분산 라우팅의 하이브리드 형태입니다. 네트워크 계층에 따라 같은 계층 안에서는 중앙 라우팅을, 외부 계층에 대해서는 분산 라우팅을 통해 경로를 계산합니다.

### 라우팅 방법
- 1. Flooding
    보낼 수 있는 모든 경로에 대해 패킷을 보냅니다. 주로 브로드캐스팅을 위해 사용됩니다.
- 2. 거리 벡터 라우팅(RIP)
    링크 벡터: 직접적으로 연결된 네트워크 정보, L(R) = [Port#n(Net#n), Port#m(Net#m), ...]  
    거리 벡터: 전체 네트워크에 소속된 개별 네트워크들까지의 거리(전송 지연시간) 정보 D(R) = [(net1, 1), (net2, 1), (net3, 2), ...]  
    다음 홉 벡터: 대상 네트워크로 보낼 다음 홉 정보 H(x) = [(net1, Rn), (net2, Rm), ...]  
    정보 갱신: 인접한 라우터로부터 거리 벡터를 받음. 거리 벡터 + 대상 라우터간의 거리가 현재 저장된 거리벡터보다 작으면 거리벡터, 홉 벡터 갱신  
    전체 IP주소가 아닌, 주소 앞 부분의 네트워크 주소만을 가지고 목적지를 등록. cmd 플래그 값이 1이면 RIP요청, 2면 응답
- 3. 링크 상태 라우팅(OSPF)(다익스트라 알고리즘)  
    자신의 링크 벡터에 변화가 있을 시 링크 벡터를 모든 라우터에 브로드캐스트. 각 라우터는 그런 정보를 받아서 경로를 계산함.  
    거리 벡터와의 차이점 - 거리 벡터는 자신과 <b>인접한</b> 라우터들간의 정보 공유.  
    링크 상태는 자신의 정보를 네트워크 내의 <b>모든</b> 라우터들에게 브로드캐스트
- 4. 외부 라우팅 프로토콜(BGP)
    단순히 외부 네트워크와, 연결이 돼 있으면 전송. 경로가 단순하기에(보통 하나의 큰 게이트웨이만 존재) 경로 계산 없이 보내기만 하면 됨. 
 
## Internet Protocol (IP)
```c
// IPv4 헤더
 0    3       7           13  15                              31
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Ver |  H_L  |     DS    |ECN|          Packet Length        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification      |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     TTL     |   Transport   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Source Address                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Destination Address                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Options / Padding                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

```
- 종단간의 통신을 위한 프로토콜
- 비 연결형 서비스, 패킷 분할 및 병합, 헤더 체크섬, Best Effort 원칙 
- 헤더는 32비트(워드)의 배수가 되도록 패딩을 붙임 

### 패킷 분할 (Fragmentation)
경로상의 라우터나 스위치가 처리할 수 있는 패킷, 프레임의 최대 크기(mtu)를 초과하는 패킷이 있을 수 있습니다.  
라우터는 이를 판단하고 다음 경로상의 라우터의 mtu보다 보낼 패킷 크기가 더 크다면, 패킷을 분할하여 보냅니다.  
분할된 패킷은 그대로 계속 라우팅 되어 목적지까지 도착한 후 목적지 호스트가 패킷을 조립하여 사용합니다.  

패킷 분할은 페이로드를 8바이트 단위로 자릅니다(마지막 패킷은 자유). 즉, 102바이트짜리 페이로드를 보낼 때, 32, 32, 32, 6 바이트로 잘릴 수 있습니다. (51, 51바이트는 안 됨)  
8바이트 단위로 자르는 이유는, 이 패킷의 Fragment Offset으로 사용하기 위한 비트 수를 절약할 수 있기 때문입니다.  
즉, 1바이트 단위로 자르는 것보다 8바이트 단위로 자르는 것이 패킷 오프셋을 표현하기 위한 비트 수가 3비트 절약된다는 장점이 있습니다.  

**더 들어가기**  
IP헤더의 패킷 길이 표현은 16비트입니다. Fragmentation에 사용되는 비트는 16개이지만, 앞의 3개는 (예약됨, 분할가능여부, 마지막 조각 여부)로 쓰이고 뒤의 13개가 Fragment Offset으로 쓰입니다.  
즉, 패킷 분할을 8바이트 단위로 함으로써 최대 패킷 길이를 조작할 수 있게 됩니다. 

## Dynamic Host Configuration Protocol (DHCP)
동적 IP 할당 프로토콜  
통신 과정    
Host -> Server 저 IP 할당받고 싶어요 여기 DHCP 서버 있나요(브로드캐스트) DHCP_DISCOVER  
Server -> Host 이 IP 쓸래?                      DHCP_OFFER  
Host -> Server 네 그 IP 쓸래요, 쓸 수 있을까요?    DHCP_REQUEST  
Server -> Host 그래 너 그 IP 써 / 아니 너 쓰지마   DHCP_ACK / DHCP_NACK  

## Address Resolution Protocol (ARP)
목적지의 IP 주소를 통해 대상 호스트의 MAC 주소를 얻는 프로토콜

RARP: 호스트가 자신의 IP 주소를 모름(스토리지에 저장을 못 하는 경우) -> 자신의 mac주소를 브로드캐스팅해 그에 대응되는 ip주소를 받아서 자신이 사용함 

## Internet Control Message Protocol (ICMP)
오류 메시지나 ping 송수신 (TTL 만료 알림, 패킷 누수, 목적지 접근 불가)

## Software Defined Network (SDN)
- Control Plane: 라우팅 알고리즘을 수행하는 부분 (논리적 구분)
- Data Plane: 포워딩을 수행하는 부분 
- SDN: 포워딩을 수행하는 Data Plane과 라우팅을 수행하는 Control Palne으로 라우터의 기능을 분리해 독립적인 모듈로 구분하고자 하는 개념. 
기존의 라우팅 방식은 각각의 라우터가 독립적인 라우팅 테이블을 만들어 계산하는 방식  
SDN은 경로 계산을 라우터가 직접 하지 않고 중앙 네트워크 운영 시스템, SDN 컨트롤러에게서 라우팅 로직을 받아 라우팅을 수행  
훨씬 유동적이고 일반적인 소프트웨어, 프로그램 형태의 라우팅 규칙을 수립 가능. 
라우터는 데이터 플레인, 포워딩 부분에 치중되어 스위치 동작을 잘 하는 것에 집중  

Input Ports를 통한 동시 다발적인 데이터 수신, Switching fabric을 통한 데이터 포워딩, Output Ports를 통한 데이터 송신을 잘 하는 것에 대해 연구  
큐잉, 스케줄링, 내부 데이터 송수신(메모리, 버스, interconnected network) 등 

# Transport Layer
프로세스간의 통신을 처리하는 계층입니다.   
- 흐름 제어: 슬라이딩 윈도우
- 오류 제어
- 분할 및 병합
- 포트번호, ip 주소 쌍 
- 상방향 멀티플렉싱: 여러개 프로세스가 하나의 네트워크 인터페이스 사용
- 하방향 멀티플렉싱: 하나의 프로세스가 여러개의 네트워크 인터페이스 사용
- 전송단위: 세그먼트, 데이터그램
## TCP
- Three-Way Handshake 연결수립:  
- 1. a가 b로 n 시퀀스 번호로 시작하는 세그먼트들을 보내겠다고 SYN을 보냄 
- 2. b가 a로 n + 1 세그먼트 달라는 ACK와 자신도 시퀀스 번호 m부터 시작하는 세그먼트들을 보내겠다는 SYN을 보냄
- 3. a가 b로 m + 1 세그먼트 달라는 ACK와 함께 자신의 데이터들을 보내기 시작함 
- 수신자가 상대방에게 자신의 Window=n이라는 슬라이딩 윈도우 크기를 알려주는 세그먼트를 보냄 -> 송신자는 한 번에 최대 n개 바이트 보냄 
- 전송 오류 발생시: NACK 없이, ACK를 보내지 않음을써 타임아웃을 통해 송신 측에서 재전송이 이뤄짐 
- Four-Way Handshake 연결해제(점진적 연결 해제 방식):
- 1. a가 b로 연결 해제 FIN을 보냄 
- 2. b가 a로 FIN 받았다는 ACK를 보냄
- 3. b가 a로 FIN을 보냄
- 4. a가 b로 FIN 받았다는 ACK를 보냄
### 혼잡 제어
- 혼잡 탐지 방법
- 1. Time Out 발생. Data를 보냈는데 그에 대한 ACK가 안 옴
- 2. 3 duplicate ACK. 동일한 ACK를 3번 받음 
#### Additive Increase Multiplicative control 
- Slow Start: 초기 cwnd 설정은 1 MSS로 시작. ACK 받을 때마다 cwnd 크기 1MSS씩 증가(RTT 마다 윈도우 크기 2배씩 증가함(ACK도 2배씩 받으니까))(Maximum Segment Size)
- Congestion Avoidance: cwnd가 일정 크기 도달하면 선형적으로 증가시킴(무작성 지수형태로 증가시켜서 과도하게 윈도우 증감 시키는걸 방지)(ssthresh)
- Fast Recovery: 3-d-A 발생시 cwnd 크기 감소
- Tahoe 방식: 혼잡 발생시(TimeOut, 3-d-A) cwnd 크기 1로 감소
- Reno 방식: 3-d-A 발생시 cwnd 크기 1/2로 감소. (cwnd = cwnd/2 로 설정하고, 3번의 중복 ACK 각각에 대해 cwnd += 1 MSS 동작을수행 => cwnd = cwnd/2 + 3 MSS)

#### ECN 플래그
- 라우터가 혼잡을 감지하면 ECN 플래그 값을 설정함(11)
- 호스트, 프로세스가 혼잡을 감지하고서 송신 윈도우를 감소하고 라우터에게 조치 했다는 통보를 보냄
- ECN기능을 지원하는 라우터가 따로 존재

## UDP
- 연결수립을 하지 않음, 세그먼트 정렬 없이 하나의 데이터그램으로 통신
- ACK를 보내지 않음 -> 신뢰성 하락
- 헤더 크기가 작고 동작이 단순함 -> tcp에 비해 상대적으로 오버헤드가 작음
- 슬라이딩 윈도우 없음 흐름제어 안 함

## RTP (Real Time Protocol)
- tcp와 udp의 속성을 혼합한 프로토콜, (UDP 위에서 구현)
- 주로 스트리밍 서비스에서 사용
- 순서번호, 타임스탬프 사용 


# Session Layer
# Presentation Layer
# Application Layer